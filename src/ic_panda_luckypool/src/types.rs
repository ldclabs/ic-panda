use base64::{engine::general_purpose, Engine};
use candid::{CandidType, Nat, Principal};
use ciborium::from_reader;
use ic_stable_structures::Storable;
use lib_panda::Challenge;
use serde::{Deserialize, Serialize};
use serde_bytes::ByteBuf;
use url::Url;

use crate::{store, utils, MAX_PRIZE_CLAIMABLE, TOKEN_1};

#[derive(CandidType, Clone, Serialize)]
pub struct CaptchaOutput {
    pub img_base64: String,
    pub challenge: String,
}

#[derive(CandidType, Clone, Deserialize)]
pub struct AirdropClaimInput {
    pub code: String,      // used as prize cryptogram
    pub challenge: String, // used as x-auth challenge
    pub lucky_code: Option<String>,
    pub recaptcha: Option<String>, // deprecated
}

#[derive(CandidType, Clone, Deserialize)]
pub struct AirdropHarvestInput {
    // Token amount in E8
    pub amount: Nat,
    pub recaptcha: Option<String>, // deprecated
}

#[derive(CandidType, Clone, Serialize)]
pub struct AirdropStateOutput {
    pub lucky_code: Option<String>,
    // claimed tokens in E8
    pub claimed: Nat,
    // claimable tokens in E8
    pub claimable: Nat,
}

#[derive(CandidType, Clone, Deserialize)]
pub struct LuckyDrawInput {
    // ICP tokens to be used for luckydraw, [0.1, 10]
    pub icp: u8,
    pub amount: Option<Nat>,
}

#[derive(CandidType, Clone, Serialize)]
pub struct LuckyDrawOutput {
    // Token amount in E8
    pub amount: Nat,
    // random lucky number generated by luckydraw
    pub random: u64,
    pub luckypool_empty: bool,
    pub prize_cryptogram: Option<String>,
    pub airdrop_cryptogram: Option<String>,
}

#[derive(CandidType, Clone, Deserialize)]
pub struct AddPrizeInput {
    pub expire: u16,       // in minutes, should be less than 60*24*30
    pub total_amount: u32, // in tokens, should be less than 100_000
    pub quantity: u16,     // should be less than 10000
    pub kind: Option<u8>,
    pub memo: Option<ByteBuf>,
    pub recipient: Option<Principal>,
}

impl AddPrizeInput {
    pub fn validate(&self) -> Result<(), String> {
        if self.expire < 10 {
            return Err("expire should be at least 10 minutes".to_string());
        }
        if self.total_amount == 0 {
            return Err("total amount should be at least 1 token".to_string());
        }
        if self.quantity == 0 {
            return Err("quantity should be at least 1".to_string());
        }
        if self.expire > 60 * 24 * 30 {
            return Err("expire should be less than 60*24*30".to_string());
        }
        if self.total_amount > 1_000_000 {
            return Err("total amount should be less than 1_000_000".to_string());
        }
        if self.quantity > 10_000 {
            return Err("quantity should be less than 10_000".to_string());
        }
        if self.total_amount / self.quantity as u32 > MAX_PRIZE_CLAIMABLE as u32 {
            return Err("amount per user should be less than 420_000".to_string());
        }
        if self.kind.unwrap_or_default() > 1 {
            return Err("kind should be less than 2".to_string());
        }
        if let Some(ref memo) = self.memo {
            let memo: PrizeMemo =
                from_reader(&memo[..]).map_err(|_err| "invalid memo".to_string())?;
            memo.validate()?;
        }
        if self.recipient.is_some() && self.quantity > 1 {
            return Err("quantity should be 1 with recipient".to_string());
        }

        Ok(())
    }
}

#[derive(CandidType, Clone, Deserialize)]
pub struct ClaimPrizeInput {
    pub code: String,
    pub challenge: ByteBuf,
}

#[derive(CandidType, Clone, Serialize)]
pub struct PrizeOutput {
    pub id: ByteBuf,
    pub issuer: String,
    pub issued_at: u64, // in seconds since UNIX epoch
    pub expire: u64,    // in seconds
    pub amount: u64,    // in E8
    pub quantity: u16,
    pub kind: u8, // 0 - fixed, 1 - random
    pub fee: u64,
    pub sys_subsidy: u64,
    pub refund_amount: u64,
    pub filled: u16,
    pub ended_at: u64, // in seconds
    pub memo: Option<ByteBuf>,
    pub name: Option<String>, // issuer name
    pub code: Option<String>,
}

impl PrizeOutput {
    pub fn from(
        prize: &store::Prize,
        info: &store::PrizeInfo,
        name: Option<String>,
        code: Option<String>,
    ) -> Self {
        Self {
            id: ByteBuf::from(prize.to_bytes()),
            issuer: utils::luckycode_to_string(prize.0),
            issued_at: prize.1 as u64 * 60,
            expire: prize.2 as u64 * 60,
            amount: prize.3 as u64 * TOKEN_1,
            quantity: prize.4,
            kind: info.0,
            fee: info.1,
            sys_subsidy: info.2 as u64 * TOKEN_1,
            refund_amount: info.3,
            filled: info.4,
            ended_at: info.5,
            memo: info.6.clone(),
            name,
            code,
        }
    }
}

#[derive(CandidType, Clone, Serialize)]
pub struct AirdropCodeOutput {
    pub issuer: String,
    pub issued_at: u64, // in seconds since UNIX epoch
    pub expire: u64,    // in seconds
    pub amount: u64,    // in E8
    pub quantity: u16,
    pub filled: u16,
    pub name: Option<String>, // issuer name
    pub code: Option<String>,
}

#[derive(CandidType, Clone, Deserialize, Serialize)]
pub struct PrizeMemo {
    pub message: String,
    pub link: String,
}

impl PrizeMemo {
    pub fn validate(&self) -> Result<(), String> {
        if self.message.is_empty() {
            return Err("message should not be empty".to_string());
        }

        if self.message.chars().count() > 100 {
            return Err("message should be less than 100 characters".to_string());
        }

        if !self.link.is_empty() && !Url::parse(&self.link).is_ok() {
            return Err("invalid link in memo".to_string());
        }

        Ok(())
    }
}

#[derive(CandidType, Clone, Deserialize, Serialize)]
pub struct Notification {
    pub id: u8,
    pub level: u8,
    pub timeout: u16,
    pub dismiss: bool,
    pub message: String,
}

#[derive(CandidType, Clone, Deserialize, Serialize)]
pub struct AirdropLog {
    pub id: Nat,
    pub ts: u64,
    pub caller: Principal,
    pub amount: Nat,
    pub lucky_code: String,
}

#[derive(CandidType, Clone, Deserialize, Serialize)]
pub struct LuckyDrawLog {
    pub id: Nat,
    pub ts: u64,
    pub caller: Principal,
    pub amount: Nat,
    pub icp_amount: Nat,
    pub random: u64,
}

#[derive(CandidType, Clone, Serialize)]
pub struct PrizeClaimLog {
    pub prize: PrizeOutput,
    pub claimed_at: u64,
    pub amount: Nat,
}

#[derive(CandidType, Clone, Deserialize)]
pub struct NameInput {
    pub name: String,
    pub old_name: Option<String>,
}

impl NameInput {
    pub fn validate(&self) -> Result<(), String> {
        utils::valid_name(&self.name.to_lowercase())?;

        if let Some(old) = &self.old_name {
            if old.is_empty() {
                return Err("old name should not be empty".to_string());
            }
            if old == &self.name {
                return Err("new name should be different from the old name".to_string());
            }
        }

        Ok(())
    }
}

#[derive(CandidType, Clone, Deserialize, Serialize)]
pub struct NameOutput {
    pub code: String,
    pub name: String,
    pub created_at: u64,
    pub deposit: Nat,
    pub annual_fee: Nat,
}

#[derive(Clone, Deserialize, Serialize)]
pub struct ChallengeCode {
    pub code: String,
}

impl ChallengeCode {
    pub fn sign_to_base64(&self, key: &[u8], timestamp: u64) -> String {
        let challenge: Vec<u8> = self.challenge(key, timestamp);
        general_purpose::URL_SAFE_NO_PAD.encode(challenge)
    }

    pub fn verify_from_base64(
        &self,
        key: &[u8],
        expire_at: u64,
        challenge: &str,
    ) -> Result<(), String> {
        let challenge = general_purpose::URL_SAFE_NO_PAD
            .decode(challenge.as_bytes())
            .map_err(|_err| "invalid challenge".to_string())?;
        self.verify(key, expire_at, &challenge)
    }
}

#[cfg(test)]
mod test {
    use super::*;

    #[test]
    fn test_challenge() {
        let key = b"secret key";
        let challenge = ChallengeCode {
            code: "challenge".to_string(),
        };
        let expire_at = 1000;
        let b64 = challenge.sign_to_base64(key, expire_at);
        assert!(challenge.verify_from_base64(key, expire_at, &b64).is_ok());
    }
}
