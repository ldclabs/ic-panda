use base64::{engine::general_purpose, Engine};
use candid::CandidType;
use serde::{Deserialize, Serialize};

use crate::utils::Challenge;

#[derive(CandidType, Clone, Debug, Deserialize, Serialize)]
pub struct CaptchaOutput {
    pub img_base64: String,
    pub challenge: String,
}

#[derive(CandidType, Clone, Debug, Deserialize, Serialize)]
pub struct AirdropClaimInput {
    pub code: String,
    pub challenge: String,
}

#[derive(CandidType, Clone, Debug, Deserialize, Serialize)]
pub struct LuckyDrawInput {
    // ICP tokens to be used for luckydraw, [1, 10]
    pub icp: u8,
}

#[derive(CandidType, Clone, Debug, Deserialize, Serialize)]
pub struct LuckyDrawOutput {
    // Token amount in E8
    pub amount: u64,
    // random number generated by luckydraw
    pub random: u32,
}

#[derive(CandidType, Clone, Debug, Deserialize, Serialize)]
pub struct LogsInput {
    pub index: Option<u64>,
}

#[derive(CandidType, Clone, Debug, Deserialize, Serialize)]
pub struct LogsOutput<T> {
    pub next_index: Option<u64>,
    pub logs: Vec<T>,
}

#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct ChallengeCode {
    pub code: String,
}

impl ChallengeCode {
    pub fn sign_to_base64(&self, key: &[u8], timestamp: u64) -> String {
        let challenge: Vec<u8> = self.challenge(key, timestamp);
        general_purpose::URL_SAFE_NO_PAD.encode(challenge)
    }

    pub fn verify_from_base64(
        &self,
        key: &[u8],
        expire_at: u64,
        challenge: &str,
    ) -> Result<(), String> {
        let challenge = general_purpose::URL_SAFE_NO_PAD
            .decode(challenge.as_bytes())
            .map_err(|_err| "invalid challenge".to_string())?;
        self.verify(key, expire_at, &challenge)
    }
}
