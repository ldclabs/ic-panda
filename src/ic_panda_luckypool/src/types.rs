use base64::{engine::general_purpose, Engine};
use candid::{CandidType, Nat, Principal};
use serde::{Deserialize, Serialize};

use crate::utils::Challenge;

#[derive(CandidType, Clone, Serialize)]
pub struct CaptchaOutput {
    pub img_base64: String,
    pub challenge: String,
}

#[derive(CandidType, Clone, Deserialize)]
pub struct AirdropClaimInput {
    pub code: String,
    pub challenge: String,
    pub lucky_code: Option<String>,
}

#[derive(CandidType, Clone, Deserialize)]
pub struct AirdropHarvestInput {
    // Token amount in E8
    pub amount: Nat,
}

#[derive(CandidType, Clone, Serialize)]
pub struct AirdropStateOutput {
    pub lucky_code: Option<String>,
    // claimed tokens in E8
    pub claimed: Nat,
    // claimable tokens in E8
    pub claimable: Nat,
}

#[derive(CandidType, Clone, Deserialize)]
pub struct LuckyDrawInput {
    // ICP tokens to be used for luckydraw, [1, 10]
    pub icp: u8,
}

#[derive(CandidType, Clone, Serialize)]
pub struct LuckyDrawOutput {
    // Token amount in E8
    pub amount: Nat,
    // random lucky number generated by luckydraw
    pub random: u64,
    pub luckypool_empty: bool,
}

#[derive(CandidType, Clone, Deserialize, Serialize)]
pub struct Notification {
    pub id: u8,
    pub level: u8,
    pub timeout: u16,
    pub dismiss: bool,
    pub message: String,
}

#[derive(CandidType, Clone, Deserialize, Serialize)]
pub struct AirdropLog {
    pub id: Nat,
    pub ts: u64,
    pub caller: Principal,
    pub amount: Nat,
    pub lucky_code: String,
}

#[derive(CandidType, Clone, Deserialize, Serialize)]
pub struct LuckyDrawLog {
    pub id: Nat,
    pub ts: u64,
    pub caller: Principal,
    pub amount: Nat,
    pub icp_amount: Nat,
    pub random: u64,
}

#[derive(Clone, Deserialize, Serialize)]
pub struct ChallengeCode {
    pub code: String,
}

impl ChallengeCode {
    pub fn sign_to_base64(&self, key: &[u8], timestamp: u64) -> String {
        let challenge: Vec<u8> = self.challenge(key, timestamp);
        general_purpose::URL_SAFE_NO_PAD.encode(challenge)
    }

    pub fn verify_from_base64(
        &self,
        key: &[u8],
        expire_at: u64,
        challenge: &str,
    ) -> Result<(), String> {
        let challenge = general_purpose::URL_SAFE_NO_PAD
            .decode(challenge.as_bytes())
            .map_err(|_err| "invalid challenge".to_string())?;
        self.verify(key, expire_at, &challenge)
    }
}

#[cfg(test)]
mod test {
    use super::*;

    #[test]
    fn test_challenge() {
        let key = b"secret key";
        let challenge = ChallengeCode {
            code: "challenge".to_string(),
        };
        let expire_at = 1000;
        let b64 = challenge.sign_to_base64(key, expire_at);
        assert!(challenge.verify_from_base64(key, expire_at, &b64).is_ok());
    }
}
